




<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=2.0, minimum-scale=0.9">

  <title>zbar-wasm Barcode Scanner Demo</title>

  <link rel="stylesheet" href="style.css">
</head>

<body>
<div class="container">
  <h1>zbar-wasm Barcode Scanner Demo</h1>

  <button id="videoBtn">Start/Stop Camera</button>

  <div class="viewport">
    <canvas id="canvas"></canvas>
    <video id="video" muted autoplay playsinline></video>
  </div>

  <h2>Result</h2>

  <div>
    <pre id="result"></pre>
    <div>
      <div id="timing">
        Using <code>OffscreenCanvas</code> for image transfer: <span id="usingOffscreenCanvas"></span><br>
        Time since previous scan: <span id="waitingTime"></span> ms<br>
        <code>drawImage()</code>: <span id="drawImageTime"></span> ms<br>
        <code>getImageData()</code>: <span id="getImageDataTime"></span> ms<br>
        <code>scanImageData()</code>: <span id="scanImageDataTime"></span> ms
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@undecaf/zbar-wasm@0.11.0/dist/index.js"></script>
<script src="script.js"></script>

</body>


<script>
    const el = {},
  usingOffscreenCanvas = isOffscreenCanvasWorking();

document
  .querySelectorAll("[id]")
  .forEach((element) => (el[element.id] = element));

let offCanvas,
  afterPreviousCallFinished,
  requestId = null;

el.usingOffscreenCanvas.innerText = usingOffscreenCanvas ? "yes" : "no";

function isOffscreenCanvasWorking() {
  try {
    return Boolean(new OffscreenCanvas(1, 1).getContext("2d"));
  } catch {
    return false;
  }
}

function formatNumber(number, fractionDigits = 1) {
  return number.toLocaleString(undefined, {
    minimumFractionDigits: fractionDigits,
    maximumFractionDigits: fractionDigits,
  });
}

function detect(source) {
  const afterFunctionCalled = performance.now(),
    canvas = el.canvas,
    ctx = canvas.getContext("2d");

  function getOffCtx2d(width, height) {
    if (usingOffscreenCanvas) {
      if (
        !offCanvas ||
        offCanvas.width !== width ||
        offCanvas.height !== height
      ) {
        offCanvas = new OffscreenCanvas(width, height);
      }

      return offCanvas.getContext("2d");
    }
  }

  canvas.width = source.naturalWidth || source.videoWidth || source.width;
  canvas.height = source.naturalHeight || source.videoHeight || source.height;

  if (canvas.height && canvas.width) {
    const offCtx = getOffCtx2d(canvas.width, canvas.height) || ctx;

    offCtx.drawImage(source, 0, 0);

    const afterDrawImage = performance.now(),
      imageData = offCtx.getImageData(0, 0, canvas.width, canvas.height),
      afterGetImageData = performance.now();

    return zbarWasm.scanImageData(imageData).then((symbols) => {
      const afterScanImageData = performance.now();

      symbols.forEach((symbol) => {
        const lastPoint = symbol.points[symbol.points.length - 1];
        ctx.moveTo(lastPoint.x, lastPoint.y);
        symbol.points.forEach((point) => ctx.lineTo(point.x, point.y));

        ctx.lineWidth = Math.max(
          Math.min(canvas.height, canvas.width) / 100,
          1
        );
        ctx.strokeStyle = "#00e00060";
        ctx.stroke();
      });

      symbols.forEach((s) => (s.rawValue = s.decode("utf-8")));

      symbols.forEach((s) => {
        delete s.type;
        delete s.data;
        delete s.points;
        delete s.time;
        delete s.cacheCount;
      });

      el.result.innerText = JSON.stringify(symbols, null, 2);

      el.waitingTime.innerText = formatNumber(
        afterFunctionCalled - afterPreviousCallFinished
      );
      el.drawImageTime.innerText = formatNumber(
        afterDrawImage - afterFunctionCalled
      );
      el.getImageDataTime.innerText = formatNumber(
        afterGetImageData - afterDrawImage
      );
      el.scanImageDataTime.innerText = formatNumber(
        afterScanImageData - afterGetImageData
      );
      el.timing.className = "visible";

      afterPreviousCallFinished = performance.now();
    });
  } else {
    el.result.innerText = "Source not ready";
    el.timing.className = "";

    return Promise.resolve();
  }
}

function detectVideo(active) {
  if (active) {
    detect(el.video).then(
      () => (requestId = requestAnimationFrame(() => detectVideo(true)))
    );
  } else {
    cancelAnimationFrame(requestId);
    requestId = null;
  }
}

el.videoBtn.addEventListener("click", (event) => {
  if (!requestId) {
    navigator.mediaDevices
      .getUserMedia({ audio: false, video: { facingMode: "environment" } })
      .then((stream) => {
        el.videoBtn.className = "button-primary";

        el.video.srcObject = stream;
        detectVideo(true);
      })
      .catch((error) => {
        el.result.innerText = JSON.stringify(error);
        el.timing.className = "";
      });
  } else {
    el.videoBtn.className = "";

    detectVideo(false);
  }
});
</script>

</html>